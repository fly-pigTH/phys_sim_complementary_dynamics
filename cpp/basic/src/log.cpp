#include "basic/include/log.hpp"

namespace phys_sim_complementary_dynamics {

static const std::string RedHead() {
    return "\x1b[6;30;91m";
}

static const std::string RedTail() {
    return "\x1b[0m";
}

static const std::string YellowHead() {
    return "\x1b[6;30;93m";
}

static const std::string YellowTail() {
    return "\x1b[0m";
}

static const std::string GreenHead() {
    return "\x1b[6;30;92m";
}

static const std::string GreenTail() {
    return "\x1b[0m";
}

static const std::string CyanHead() {
    return "\x1b[6;30;96m";
}

static const std::string CyanTail() {
    return "\x1b[0m";
}

void PrintInfo(const std::string& location, const std::string& message) {
    std::cout << CyanHead() << "[" << location << "]: " << message << CyanTail()
        << std::endl;
}

void PrintWarning(const std::string& location, const std::string& message) {
    std::cout << YellowHead() << "[" << location << "]: " << message
        << YellowTail() << std::endl;
}

void PrintError(const std::string& location, const std::string& message) {
    std::stringstream ss;
    ss << RedHead() << "[" << location << "]: " << message << RedTail()
        << std::endl;
    std::cerr << ss.str();
    throw std::runtime_error(ss.str());
}

void PrintSuccess(const std::string& location, const std::string& message) {
    std::cout << GreenHead() << "[" << location << "]: " << message
        << GreenTail() << std::endl;
}

void CheckCondition(const bool condition, const std::string& location,
    const std::string& message) {
    if (!condition) {
        PrintError(location, message);
    }
}

const bool StartWith(const std::string& full, const std::string& prefix) {
    if (full.size() < prefix.size()) return false;
    return std::equal(prefix.begin(), prefix.end(), full.begin());
}

const bool EndWith(const std::string& full, const std::string& suffix) {
    if (full.size() < suffix.size()) return false;
    return std::equal(suffix.rbegin(), suffix.rend(), full.rbegin());
}

// Timing.
static std::stack<timeval> t_begins;

void Tic() {
    timeval t_begin;
    gettimeofday(&t_begin, nullptr);
    t_begins.push(t_begin);
}

void Toc(const std::string& location, const std::string& message) {
    timeval t_end;
    gettimeofday(&t_end, nullptr);
    timeval t_begin = t_begins.top();
    const real t_interval = (t_end.tv_sec - t_begin.tv_sec)
        + (t_end.tv_usec - t_begin.tv_usec) / 1e6;
    std::cout << "[" << location << "]: (" << t_interval << "s) " << message
        << std::endl;
    t_begins.pop();
}

const real Toc() {
    timeval t_end;
    gettimeofday(&t_end, nullptr);
    timeval t_begin = t_begins.top();
    const real t_interval = (t_end.tv_sec - t_begin.tv_sec)
        + (t_end.tv_usec - t_begin.tv_usec) / 1e6;
    t_begins.pop();

    return t_interval;
}

template<>
void Save<integer>(std::ofstream& f, const integer& val) {
    const int64_t val_cast = static_cast<int64_t>(val);
    f.write(reinterpret_cast<const char*>(&val_cast), sizeof(int64_t));
}

template<>
void Save<real>(std::ofstream& f, const real& val) {
    const double val_cast = static_cast<double>(val);
    f.write(reinterpret_cast<const char*>(&val_cast), sizeof(double));
}

template<>
const integer Load<integer>(std::ifstream& f) {
    int64_t val = 0;
    f.read(reinterpret_cast<char*>(&val), sizeof(int64_t));
    return static_cast<integer>(val);
}

template<>
const real Load<real>(std::ifstream& f) {
    double val = 0;
    f.read(reinterpret_cast<char*>(&val), sizeof(double));
    return static_cast<real>(val);
}

void SaveVectorXr(const std::string& file_name, const VectorXr& vec) {
    std::ofstream f(file_name);
    const integer num = static_cast<integer>(vec.size());
    Save<integer>(f, num);
    for (integer i = 0; i < num; ++i) {
        Save<real>(f, vec(i));
    }
}

const VectorXr LoadVectorXr(const std::string& file_name) {
    std::ifstream f(file_name);
    const integer num = Load<integer>(f);
    VectorXr vec = VectorXr::Zero(num);
    for (integer i = 0; i < num; ++i) {
        vec(i) = Load<real>(f);
    }
    return vec;
}

const std::pair<Matrix3Xr, Matrix3Xi> LoadObjMesh(
    const std::string& file_name) {

    std::ifstream file(file_name);
    std::vector<Vector3r> vertices_data;
    std::vector<Vector3i> elements_data;

    std::string line;
    integer vertex_num = 0;
    integer element_num = 0;
    while (std::getline(file, line)) {
        // We refer to a simple obj generated by meshlab which consists of only
        // three things:
        // - Comments: it begins with #.
        // - Vertices: it begins with v followed by three floats.
        // - Triangles: it begins with f followed by three ints.
        // No normals or textures.
        if (line[0] == '#') {
            continue;
        } else if (line[0] == 'v') {
            std::stringstream ss(line.substr(2));
            Vector3r vertex;
            ss >> vertex.x() >> vertex.y() >> vertex.z();
            vertices_data.push_back(vertex);
            ++vertex_num;
        } else if (line[0] == 'f') {
            std::stringstream ss(line.substr(2));
            Vector3i element;
            ss >> element.x() >> element.y() >> element.z();
            // Obj vertex indices begin at 1 instead of 0.
            elements_data.push_back(element.array() - 1);
            ++element_num;
        }
    }
    CheckCondition(vertex_num >= 3 && element_num > 0, "basic::LoadObjMesh",
        "Failed to load obj.");
    Matrix3Xr vertices(3, vertex_num);
    for (integer i = 0; i < vertex_num; ++i)
        vertices.col(i) = vertices_data[i];
    Matrix3Xi elements(3, element_num);
    for (integer i = 0; i < element_num; ++i)
        elements.col(i) = elements_data[i];

    return { vertices, elements };
}

const MeditMesh LoadMeditMesh(const std::string& file_name) {
    const std::string error_location = "basic::LoadMeditMesh";

    MeditMesh mesh;

    std::ifstream file(file_name);
    std::string line;
    // MeshVersionFormatted 1.
    std::getline(file, line);
    CheckCondition(StartWith(line, "MeshVersionFormatted"), error_location,
        "Expect to see MeshVersionFormatted.");
    std::getline(file, line);
    // Dimension 3.
    CheckCondition(StartWith(line, "Dimension"), error_location,
        "Expect to see Dimension.");

    // Vertex number.
    std::getline(file, line);
    CheckCondition(line == "Vertices", error_location,
        "Expect to see Vertices.");
    std::getline(file, line);
    std::stringstream vertex_num_ss(line);
    vertex_num_ss >> mesh.vertex_num;
    mesh.vertices = Matrix3Xr::Zero(3, mesh.vertex_num);
    for (integer i = 0; i < mesh.vertex_num; ++i) {
        std::getline(file, line);
        std::stringstream ss(line);
        ss >> mesh.vertices(0, i) >> mesh.vertices(1, i) >> mesh.vertices(2, i);
    }

    // Triangle number.
    std::getline(file, line);
    CheckCondition(line == "Triangles", error_location,
        "Expect to see Triangles.");
    std::getline(file, line);
    std::stringstream triangle_num_ss(line);
    triangle_num_ss >> mesh.triangle_num;
    mesh.triangles = Matrix3Xi::Zero(3, mesh.triangle_num);
    for (integer i = 0; i < mesh.triangle_num; ++i) {
        std::getline(file, line);
        std::stringstream ss(line);
        integer idx0, idx1, idx2;
        ss >> idx0 >> idx1 >> idx2;
        mesh.triangles(0, i) = idx0 - 1;
        mesh.triangles(1, i) = idx1 - 1;
        mesh.triangles(2, i) = idx2 - 1;
    }

    // Tetrahedra number.
    std::getline(file, line);
    CheckCondition(line == "Tetrahedra", error_location,
        "Expect to see Tetrahedra.");
    std::getline(file, line);
    std::stringstream tetrahedron_num_ss(line);
    tetrahedron_num_ss >> mesh.tetrahedron_num;
    mesh.tetrahedrons = Matrix4Xi::Zero(4, mesh.tetrahedron_num);
    for (integer i = 0; i < mesh.tetrahedron_num; ++i) {
        std::getline(file, line);
        std::stringstream ss(line);
        integer idx0, idx1, idx2, idx3;
        ss >> idx0 >> idx1 >> idx2 >> idx3;
        mesh.tetrahedrons(0, i) = idx0 - 1;
        mesh.tetrahedrons(1, i) = idx1 - 1;
        mesh.tetrahedrons(2, i) = idx2 - 1;
        mesh.tetrahedrons(3, i) = idx3 - 1;
    }

    return mesh;
}

}